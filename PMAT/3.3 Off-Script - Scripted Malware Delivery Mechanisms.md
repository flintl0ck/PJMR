PowerShell Script
- open in VSCode (change the file name to end with ".ps1" so VSC recognizes the file type, but this also arms the malware)
- malicious scripts will often be obfuscated to make them difficult for analysts to read, but in order to run properly they need to deobfuscate themselves
- this means we can replace portions of the script that execute the code with variable assignment
- `iEx()` is "InvokeExpression" in PowerShell, so everything within that is what is getting run
	- we take a look inside and see an object variable `nEW-ObJECt` is made and assigned a value that is a long base64 encoded string that gets decoded via `FROmbaSe64StRiNG` and then decompressed via `sYsTem.io.comprEsSIOn.CoMPReSsIONmOdE`
	- <span style="color:blueviolet;font-weight:bold">don't forget PowerShell is almost always CAsE InSEnSitIvE</span> 
- <span style="color:yellow;font-weight:bold">TIP:</span> don't forget to save an unedited copy of the malware for us to return to later
- in a PowerShell terminal, copy in the entire InvokeExpression function (including the base64 encoded bloc), then replace "`iEx(`" with "`$megasus =`" (and remove the trailing "`)`")
- you now have a variable that equals the true contents of the blob.  Print that shit
	- `write-host $megasus`

VisualBasic Script
- should immediately notice there are 3 files this time: `crtupdate.vbs`, `one.crt`, and `two.crt`
- open `crtupdate.vbs` in VSCode
	- first indicator is the creation of a `"WScript.Shell"` object.  This is a primitive in Windows that allows you to create an object for running things.
	- then we see 3 instances of the `.Exec()` execute function of `WScript.Shell` object "`WshShell`".  Each one with a very clear command within the quotation marks
	- these `.Exec()` function calls are separated by `WScript.Sleep 1000`, which is a common tactic for slowing the pace of the malware to avoid detection
	- the two `.crt` files are decoded into `one.vbs` and `xml.xml` and saved to the `C:\Users\Public\Documents` folder
	- analyzing the `one.vbs` script shows that the `update()` function is created to `Replace()` a passed string with `""` (nothing).  This is used as a convoluted way to pass a string that has been obfuscated with useless characters (in this case "vVv"), remove the obfuscating strings (replace "vVv" with "") and then assign the output to a variable (`aaa` and `aaaa`)
	- a quick and easy way to deobfuscate this would be to use the VSCode Find/Replace tool:![[Pasted image 20231126181712.png]]
	- now it's a little easier to see that `obj.Document.Application.ShellExecute` is used to call `MSBuild.exe` and `xml.xml` (the file created by the `crtupdate.vbs` script)
	- we see the `GetObject()` function being used to `.ShellExecute` our deobfuscated variables is first passed `"new:C08AFD90-F2A1-11D1-8455-00A0C91F3880"` which looks suspiciously like an SID or UID of some sort.  Googling it we find out it's a Class ID for a COM-Object, specifically the ShellBrowserWindow COM-Object.  Unsurprisingly, just googling this class ID yields a ton of info on exploitation methodologies for this COM-Object
	- Reading through the Microsoft documentation for Shell.ShellExecute we can get a better idea of what the 5 parameters being passed to that function do: https://learn.microsoft.com/en-us/windows/win32/shell/shell-shellexecute
		- `0` opens the shell in a hidden window
		- `"runas"` runs the passed command at Administrator level
- Use `MSBuild.exe` manually to build the `xml.xml` file
	- taking a quick peak at the .xml file contents we can see that it tells MSBuild that it's using C#
	- `C:\...\MSBuild.exe C:\...\xml.xml`
	- the instructor makes it seem like you can just "tell" what happened by reading the MSBuild output, but it's clear he deobfuscated the byte array'd shell code that is passed to it within the `xml.xml` C# code
		- adds a user to Remote Desktop group
		- adds that user to Administrators group
		- opens a port in the Firewall (RDP)
	- (MSBuild.exe does not have a way to output what gets run from the program you build, even using diagnostic verbosity or output summaries, so we have to read through the actual C# code in `xml.xml`)

HTML Application (HTA) file
- using the `<script>` tag in HTML, we can run different scripting languages, usually JavaScript.  This is where a lot of the classic XSS vulnerabilities existed
- when HTML code is downloaded and run within a browser, it is confined to the browser.  By using `.hta` files we can run HTML, CSS, and JavaScript (JScript) right on the Windows OS.  Yay!
	- `.hta` files aren't limited to JScript, but can run any Windows-native scripting language as well, such as VBScript
- while this is obviously a concerning file type, it's also a little easier to analyze since it's written in plain HTML
- Open in VSCode
	- this is the same process as with the others.  The `<script>` tag calls some JavaScript and we need to figure out what it does by analyzing the function calls
	- `document.write()`: The `write()` method writes directly to an open (HTML) document stream
	- `unescape():` The `unescape()` function computes a new string in which hexadecimal escape sequences are replaced with the characters that they represent
	- seems pretty obvious what's going on here.  Grab the hex data and put it in CyberChef with the delimiter set to `%` to see the deobfuscated code
	- we can already see some `Service.Get()` calls to WMI
	- a little further down in the script we can see the `Win32_Process` object is used to `.Create(` a hidden powershell shell via cmd.exe and then `WebClient.DownloadFile(` from http[:]//tailofawhale.local/TellAndSentFor[.]exe and put it in the `Error` variable
	- the downloaded executable is then written to `%temp%\jLoader.exe` and then executed
-  <span style="color:yellow;font-weight:bold">TIP:</span> HTAs do not execute directly, so you will not be able to view them as the file name in ProcMon like other executables. When double-clicked, they are passed to the native Windows binary `mshta.exe` which executes them on its behalf. `mshta.exe` acts as an HTML interpreter and loads the HTML from the HTA along with any DLLs that deal with script execution and then executes the program all at once.
	- digging a little deeper into ProcMon we can see the hidden powershell.exe that ran from the following process tree
		- `svchost.exe` > `wmiprvse.exe` > `cmd.exe` > `powershell.exe` and then funny enough, powershell.exe spawns `jLoader.exe`
