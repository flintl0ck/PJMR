Common Language Runtime (CLR) - a single set of standard machine code instructions between many different languages.  vb.NET and F# also use the CLR, not just C#.  Everything that uses the .NET framework is going to use the CLR for the execution of its program

DLL file
- `floss Malware.cryptlib64.dll.malz`
- This floss output is surprisingly clean with some immediate potential indicators:
	- `AssemblyTitleAttribute`
	- `AssemblyProductAttribute`
	- `System.Runtime.InteropServices`
	- `mscorlib` - this one specifically tells us we're working with a C# binary
	- `.NETFramework,Version=4.7.2`

Application layers from C# code to runtime execution
![[Pasted image 20231127134108.png]]
- `mscorlib` is a series of .NET libraries that can be imported when you're building C# applications.  It is assigned dynamically at runtime and loads all of the libraries into the C# binary when it is executing in the CLR

- <span style="color:yellow;font-weight:bold">dnSpy</span> (Run as Administrator)
	- File > Open > open the malware sample
		- `dnSpy` will then take all of the Intermediate Language inside of the C# assembly dll and render it to as close to the original source code as possible.  Should be very accurate.
	- `EmbedDLL.dll`
		- open the drop downs to see the two classes within the dll, `Cryptor` and `Program`
	- `Program` class analysis
		- when analyzing a dll, the `Program` class is going to have "most of the interesting information".  It seems like this would be akin to the `Main()` method of a binary, which dlls would not normally have
		- Just like all of the others, we read through the code to get an understanding of what the class does when its called
		- A large Base64 encoded string is AES decrypted using the password "p0w3r0verwh3lm1ng!"
		- Then the contents of the decoded/decrypted string are written to `%public%\embed.xml`
		- another string variable `contents2`  is Base64 decoded and then written to `C:\Users\Public\Documents\embed.vbs`
		- then there is a try/catch that attempts to write an HKCU reg run key to run this `embed.vbs` file just created

- running the dll
	- typically dlls are called by a program to be run within the program's runtime, so they won't normally have something like a `Main()` method as we would with executables
	- using the `rundll32` command from cmder allows us to run a dll file, but we will need to pass it the name of the function within the library that we are calling to run.  With this particular dll it is the `embed` class that is the main thing returned by the dll when called.
	- `rundll32 Malware.cryptlib64.dll,embed`
	- once we run the dll using the above syntax we can see that the two file writes occur: `embed.xml` and `embed.vbs`
	- now remember, there was also a registry run key created in the HKCU hive.  Open Registry Editor from the Flare-VM start menu.  You can grab the key location from the source code in **dnSpy** but also it's in the default runkey spot: `HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run`

- open `embed.xml` in VSCode
	- at the very top of `embed.xml` we can see that this is an MSBuild script which provides instructions for something to execute
	- within the script we see some familiar indicators: a compressed and Base64 encoded blob is decoded/decompressed and placed into a `.MemoryStream()`
	- then there is `System.Reflection.Assembly.Load` which is means that whatever the Base64 blob is doing, it is then being loaded reflectively as a reflective assembly.  Common methodology for avoiding EDR and AV by loading malware into memory byte by byte

- open `embed.vbs` in VSCode
	- we see the common VBScript method to invoke and run a program:
		- `CreateObject ("WScript.Shell")`
	- the arguments `MSBuild.exe` and `\embed.xml` are passed to the shell object when it is run at the bottom

So what is actually happening here?
- every time a user logs in, the new regrun key will execute, which runs `embed.vbs
- `embed.vbs` uses the `MSBuild.exe` executable and passes it the `embed.xml` build file
- the `embed.xml` build file has a big blob of compressed/encoded text that it tells `MSBuild.exe` to load reflectively into memory as it is decoded then decompressed, at runtime

The instructor skips static analysis of the encoded blob (which could be done easily with our previous trick of changing the MSBuild script to put the decoded/decompressed output into a variable when writing it out to host for us to view), and goes directly to detonating the `embed.vbs` script to emulate a user logging in

`FakeNetNG` is similar in use to `iNetSim` but apparently less reliable.  Either way, it's used for the example here to show that a DNS request is made to srv.masterchiefsgruntemporium.local and captured in the `FakeNetNG` log.  Using this info we can derive that this is a C2 agent dropper reaching out to the listener, and if that request is successful a C2 agent will be downloaded onto the host