
<span style="color:red;font-weight:bold;font-size:1.5em">CAUTION!</span> THIS IS THE REAL WANNACRY SO CHECK THE NIC AND SAVE A NEW SNAPSHOT!
<span style="color:blue;font-weight:bold">wannacry.exe</span> 
Challenge Questions:
- Record any observed symptoms of infection from initial detonation. What are the main symptoms of a WannaCry infection?
	- several files written to desktop: `@WanaDecryptor.exe` and `@WanaDecryptor@.bmp`
	- `@WanaDecryptor@.bmp` is set to the background
	- Wana Decrypt0r 2.0 is run and opens a window with the well known ransomware instructions.  "We guarantee that you can recover all your files safely and easily. But you have not so enough time."
- Use FLOSS and extract the strings from the main WannaCry binary. Are there any strings of interest?
	- `floss -n 8 Ransomware.wannacry.exe.malz | less`
	- the DOS header let's us know this is a portable executable (which we already knew)
	- many obvious API calls and dll's loaded
	- we see multiple DOS headers (`!This program cannot be run in DOS mode.`) so we can reasonably assume that additional executables or dlls that are loaded in
	- there are a few blobs that look to be Base64 encoded
	- file paths with string token replacements: `C:\%s\quriuqjhrf` and `C:\%s\%s`
		- in C# you can use %s to place a string into the token that you can use to call that string later
	- `taskche.exe`
	- `http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea[.]com`
	- `cmd.exe`
	- `icacls . /grant Everyone:F /T /C /Q`
- Inspect the import address table for the main WannaCry binary. Are there any notable API imports?
	- open in PEStudio
	- important libraries loaded:
		- `Windows Socket 2.0 32-bit DLL`
		- `IP Helper API`
		- `Internet Extensions for Win32`
	- important imports
		- sort by blacklist
		- multiple APIs dealing with cryptography
		- winsocket API is used for `closesocket`, `recv`, `send`
		- `InternetOpenA`, `InternetOpenUrlA`
		- `CreateServiceA`, `ChangeServiceConfigA`
- What conditions are necessary to get this sample to detonate?
	- if `wannacry.exe` can successfully reach the long random URL we found in the strings, then it won't execute.  This is kind of the reverse of what we're used to seeing so if `inetsim` is running and auto-responding to all HTTP/HTTPS requests, it will actually prevent the ransomware from executing
	- you would discover this by using WireShark while triggering the binary both with and without `inetsim` enabled
- **Network Indicators**: Identify the network indicators of this malware
	- SysInternal - `tcpview.exe`
		- with tcpview running, detonate the binary
		- organize the list by `Process Name` and scroll down to the name of the executable "Ransomware.wannacry.exe.malz"
		- several network connections made over Port 445 (SMB) with lots of similar IP addresses.  This is the first indicator of worm capabilities, showcasing how the malware will attempt to identify other vulnerable hosts on the network
		- a new `taskhsvc.exe` is spawned and is listening on all interfaces on port 9050
			- I'm not actually sure how the instructor knew to look here for a new taskhsvc
- **Host-based Indicators**: Identify the host-based indicators of this malware.
	- Process Monitor
		- build some filters for "Process Name contains wannacry" and "Operation is CreateFile"
		- creation of a file `C:\Windows\taskche.exe`
			- with this event selected click the Process Tree icon ![[Pasted image 20231128162852.png]]
			- we can see `taskche.exe` is unpacked and then run with `taskche.exe /i`
			- to dig deeper we add the `taskche.exe` PID (3336 in the lesson) and filter on that as the Parent PID (taking the previous criteria filters out).  This will show all child processes from `taskche.exe`
			- add back "Operation is CreateFile"
				- `C:\ProgramData\dveqybpwqzwa072` and `C:\ProgramData\dveqybpwqzwa072\dveqybpwqzwa072`
				- this ends up being a staging are for the wannacry tools when depackaged.  We can see that this is created as a hidden directory as well
	- Task Manager
		- go to the "Services" tab to see if any new services were create
		- we see one with a matching `dveqybpwqzwa072` as the file created earlier
- Use Cutter to locate the killswitch mechanism in the decompiled code and explain how it functions.
	- open in Cutter
		- opent the `main` function
		- go to Graph mode view (tab at bottom)
			- we can see that the weird URL we identified earlier is pushed to `esi` which is later called as an argument for the `InternetOpenA` API call
		- go to Decompiler
			- we see the `InternetOpenUrlA` API call is loaded into the `eax` register
			- and then `eax` is loaded into `edi`
			- `InternetOpenUrlA` returns a boolean variable, either `True` the request to the given URL was successful or `False` the request failed.  Then this T/F value is pushed to `edi`
			- there is a pretty telling `if (edi == 0) {` after this but we'll switch to Graph mode since it's easier to view
		- return to Graph (main)
			- we can view this section at the bottom of the first function of `main`: just before the `jne`
			- `test edi, edi` then a jump if not equal (`jne`) .  Depending on the outcome of the jump, it will go to one of two places in memory
			- these two jump locations look almost identical except the one for if the web request fails there is an additional function call, `call fcn.00408090`
			- double click `fcn.00408090` to go to that section of the program and we see that it is the rest of the encryption payload: it installs itself as a service, it unpacks the rest of the resources in the binary, and will kick off the encryption routine